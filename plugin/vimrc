

"| 0. Before everything else
    " Define core directory paths
        set shellslash

        let g:dir_vim = expand('~/.vim/')
        let g:dir_notes = expand('~/Dropbox/Notes/')
        let g:dir_palettes = g:dir_notes . '_palettes/'
        let g:dir_dev = expand('~/my/')
        let g:dir_myPlugins = g:dir_dev . 'vimfiles/'

        if !isdirectory(g:dir_myPlugins)
            echom 'NOTE: Please set "g:dir_myPlugins" to valid folder'
            finish
        endif


        " Add my personal plugins
        let &runtimepath .= ',' . g:dir_myPlugins

    " Use vundle to manage plugins
        " Vundle begin
            set nocompatible
            filetype off
            let dir_vundle = g:dir_vim . 'bundle/'
            let &runtimepath .= ',' . dir_vundle . 'Vundle.vim'
            try
                call vundle#begin(dir_vundle)
            catch
                echom "NOTE: Put Vundle.vim in: " . dir_vundle
                finish
            endtry
            Plugin 'gmarik/Vundle.vim' "Vundle is required to manage itself

        " Get plugins from github
            " My faves
            Plugin 'altercation/vim-colors-solarized'
            Plugin 'tpope/vim-sleuth' "Critical to handle varying shiftwidths (eg. 4sp vs 2sp)
            Plugin 'tomtom/tcomment_vim' "Easy commenting
            Plugin 'luochen1990/rainbow' "Differentiate parentheses
            Plugin 'tpope/vim-surround' "Operations with surround chars, surprisingly useful
            Plugin 'rking/ag.vim' "Faster grep, ie. searching thru text of files

            " Could make my own version of
            Plugin 'xolox/vim-session'
            Plugin 'xolox/vim-misc'

            " Using my own custom version of below
            "Plugin 'Lokaltog/vim-easymotion'
            "Plugin 'techlivezheng/vim-plugin-minibufexpl'
            "Plugin 'henrik/vim-indexed-search'
            "Plugin 'Yggdroot/indentLine'


            " Fine, but never use
            "Plugin 'godlygeek/tabular' "Aligns text by char (eg. = or :)
            Plugin 'kchmck/vim-coffee-script'

            " Fine, but I don't want
            "Plugin 'szw/vim-ctrlspace'
            "Plugin 'severin-lemaignan/vim-minimap' "Not useful
            "Plugin 'nathanaelkane/vim-indent-guides' "Noisy-looking
            "Plugin 'raimondi/delimitmate' "Auto add matching parens (so don't forget to)
            "Plugin 'jeetsukumaran/vim-buffersaurus'
            Plugin 'tpope/vim-fugitive' "I prefer commandline
            "Plugin 'airblade/vim-gitgutter' "I prefer meld
            "Plugin 'Shougo/unite.vim'
            "Plugin 'mhinz/vim-startify' "Startup screen w MRU files and sessions
            "Plugin 'ntpeters/vim-better-whitespace' "For trailing whitespace
            "Plugin 'kien/ctrlp.vim' "Prefer my own plugins, spacework + navkey

            " To try
            "Plugin 'Valloric/YouCompleteMe'
            "Plugin 'tpope/vim-abolish' "not needed
            Plugin 'scrooloose/syntastic'
            "Plugin 'mtscout6/syntastic-local-eslint.vim'
            Plugin 'gilday/syntastic-local-standard.vim'
            "Plugin 'wookiehangover/jshint.vim'
            "Plugin 'tpope/vim-jdaddy' "Does this format json?
            "Plugin 'klen/python-mode'
            "Plugin 'hdima/python-syntax'

        " Vundle end
            call vundle#end()
            filetype plugin indent on

    " Turn on syntax highlighting
        if !exists('g:loadOnceSyntax')
            let g:loadOnceSyntax = 1
            " cmds 'colorscheme' and 'syntax enable' are fickle, so run only once
                syntax enable
                if has("gui_running")
                    colorscheme solarized
                    "colorscheme molokai
                    "colorscheme hybrid
                    "colorscheme lucius
                else
                    silent! colorscheme desert
                endif

                "set background=dark
                set background=light

                "let g:molokai_original =1
                "let g:solarized_termcolors=256

        endif

"| 1. Core options
    " Core vim options
        " Saving undo, cmds, backups
            " Save undo history, even after file is closed!
                if has('persistent_undo')
                    "Make sure dir exists
                    set undodir=~/.vim/undofiles
                    if !isdirectory(&undodir)
                        call mkdir(&undodir,"p")
                    endif
                    set undolevels=100
                    set undofile
                endif

            " Save history of commands (note: commands, not undo)
                let &viminfo .= ',n' . g:dir_vim . 'viminfo'
                set history=100

            " File backups + swaps
                let &backupdir = g:dir_vim . 'backups'
                if !isdirectory(&backupdir)
                    call mkdir(&backupdir, "p")
                endif

                let &directory = g:dir_vim . 'swaps'
                if !isdirectory(&directory)
                    call mkdir(&directory, "p")
                endif

                set backupskip=/tmp/*,/private/tmp/*
                set backup
                set writebackup

        " Disable modeline bc of security reasons
            set nomodeline
            set modelines=0

        " Set default line endings to unix for full compatability
            set fileformats=unix,dos

    " GUI and indents
        " One-liners
            " Self-explanatory
            if has('unix')
                set guifont=Consolas:h12
                set linespace=1

                "set guifont=Menlo\ Regular:h13
                "set linespace=3
            elseif has('win32')
                set guifont=Consolas:h11
                "set linespace=5
                "let &guifont = "Source_Code_Pro:h9"
            endif

            set encoding=utf8
            set showcmd
            set relativenumber
            set notimeout
            set hidden
            "set lazyredraw "for nvim, causes 'relativenumber' to flash
            set synmaxcol=200
            set wildmenu
            set wildmode=longest:list "To list all options
            set linebreak "Useful for wrapping by words
            set list
            set listchars=tab:=-
            "set ttyfast
            "set ruler
            if exists("&breakindent") "Only in version >= 8
                set breakindent
            endif

            " Turn off mouse (no cheating!)
            set mouse =
            set guicursor+=a:blinkon0
            set autoread "Auto-update file if changed outside of vim

        " Status line
            set laststatus =2
            "set statusline =\ \ 
            set statusline =\ \ 
            set statusline +=%{Scroller()}
            "set statusline +=\|
            set statusline +=%5l
            set statusline +=/
            set statusline +=%L

            "set statusline +=%02{&foldlevel}
            "set statusline +=\|
            "set statusline +=%P
            "set statusline +=\|

            ":set statusline=%<%f\ %h%m%r%=%-14.(%l,%c%V%)\ %P
            "hi User1 guibg=red guifg=blue

        " Title string
            "set titlestring=\ 
            set titlestring =%{PrintCurrFolder()}

        " Dismantle any gui toolbars
            if has("gui_running")
                set guioptions-=t
                set guioptions-=T
                set guioptions-=m
                set guioptions-=r
                set guioptions-=L
                "set guioptions-=M
            endif

        " Formatting of indents/tabs
            set expandtab
            set shiftwidth=2 "overwritten by .py (4) and .to (4)
            "set tabstop=4 "Never used
            "set softtabstop=4 "Never used

            " autoindent is *exactly* what I want: when <CR> in insert mode, matches ind of above
            "set autoindent "Enabled in autocmd
            "set smartindent "Never used

    " Syntax hl and coloring
        if exists("g:colors_name")
        " Highlight for desert
            if g:colors_name == 'desert'
                hi Folded guibg=bg ctermbg=NONE
                hi ShowCursor guibg=khaki guifg=NONE
            endif

        " Highlighting for solarized
            if g:colors_name == 'solarized'
                "hi! link Folded Normal gui=bold
                hi Folded gui=bold guifg=fg guibg=bg
                "hi Folded gui=bold
                "hi! link Folded Underlined
                hi ShowCursor guibg=fg guifg=bg
                hi! link wildmenu Cursor
                hi! link Search Visual
            endif

        " Highlighting for all colorschemes
            hi! link LineNr Folded
            hi! link CursorLineNr LineNr

            hi NonText guifg=bg guibg=bg ctermfg=NONE ctermbg=NONE
            hi VertSplit guibg=bg guifg=bg cterm=NONE ctermfg=NONE
            hi HideCursor guibg=bg
            "hi MatchParen guibg=bg guifg=grey70
            "hi Conceal guifg=grey45
            "hi! link SpecialKey Conceal

        " Highlight status line and EOF
            "hi! link StatusLine LineNr
            hi StatusLine guibg=bg gui=bold
            hi StatusLineNc guibg=bg gui=NONE ctermbg=NONE
            "hi! link StatusLineNc Comment
            "hi StatusLine guibg=grey33 guifg=gold
            "hi StatusLineNC guibg=grey25 guifg=gold
            ""hi StatusLine guibg=grey30 guifg=gold gui=bold
            ""hi StatusLineNC guibg=grey20 guifg=gold gui=bold
            ""hi StatusLine guibg=grey20 guifg=gold gui=bold
            ""hi StatusLineNC guibg=grey20 guifg=grey60 gui=bold

        endif

"| 2. Plugin options
    " For tcomment
        let g:tcommentMaps = 0 "Don't need tcomment's key maps
        let g:tcommentOptions = {'whitespace': 'no'}
        try
            call tcomment#DefineType('javascript','// %s')
            call tcomment#DefineType('cpp','// %s')
            call tcomment#DefineType('java','// %s')
            call tcomment#DefineType('todo','( %s')
        catch
            echom "NOTE: tcomment is not loaded"
        endtry

    " For gitgutter
        let g:gitgutter_sign_removed = '-'
        let g:gitgutter_sign_removed_first_line = '--'
        let g:gitgutter_sign_modified_removed = '~-'
        let g:gitgutter_map_keys = 0
        let g:gitgutter_realtime = 0
        let g:gitgutter_eager = 0
        "hi clear SignColumn "Not sure the point of this

    " For rainbow parentheses
        let g:rainbow_active = 1

        if &background == "dark"
            let brickred = '#dc322f' "best
            let purp = '#6c71c4'
            let teal = '#2aa198' "strangely good
            "let orange = '#b58900' "too strange
            let green = '#719e07' "horrifically ugly
            let blue = '#268bd2' "not distinguishable from purp/teal
            "let pink = '#d33682' "not distinguishable from red
        else
            let brickred = '#dc322f' "best
            let green = 'darkgreen' "horrifically ugly
            let blue = 'blue' "not distinguishable from purp/teal
        endif

        let g:rainbow_conf = {
            \'guifgs': [brickred, green, blue],
            \'ctermfgs': ['lightblue', 'lightyellow', 'lightcyan', 'lightmagenta'],
            \'operators': '_,_',
            \'parentheses': ['start=/(/ end=/)/ fold', 'start=/\[/ end=/\]/ fold', 'start=/{/ end=/}/ fold'],
            \'separately': {
                \'*': {},
                \'vim': {
                    \'parentheses': ['start=/(/ end=/)/', 'start=/\[/ end=/\]/', 'start=/{/ end=/}/ fold',
                    \'start=/(/ end=/)/ containedin=vimFuncBody', 'start=/\[/ end=/\]/ containedin=vimFuncBody',
                    \'start=/{/ end=/}/ fold containedin=vimFuncBody'],
                \},
                \'todo': 0,
            \}
        \}
        "\'guifgs': ['#dc322f','#afad27','seagreen3','royalblue3','darkorchid3'],
        "\ 'html': {
        "    \ 'parentheses': ['start=/\v\<((area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)[ >])@!\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'|[^ '."'".'"><=`]*))?)*\>/ end=#</\z1># fold'],
        "\ },
    " For delimitMate
        let g:delimitMate_expand_cr = 1
        let g:delimitMate_jump_expansion = 1
        let g:delimitMate_excluded_regions = ''
        let g:delimitMate_excluded_ft = 'todo'

    " For syntastic
        let g:syntastic_mode_map = {'mode': 'passive'} "Stop auto-run on save
        let g:syntastic_always_populate_loc_list = 1 "Open with <:Errors>
        let g:syntastic_auto_loc_list = 0 "Annoying
        let g:syntastic_check_on_open = 0
        let g:syntastic_check_on_wq = 0
        let g:syntastic_enable_ballons = 0
        let g:syntastic_loc_list_height = 5
        let g:syntastic_javascript_checkers = ["standard"]

    " Other
        "let g:loaded_matchparen = 1
        let g:matchparen_timeout = 10
        let g:fugitive_no_maps = 1
        let g:EasyMotion_skipfoldedline = 0
        let g:session_lock_enabled = 0
        let g:session_persist_globals = []
        call add(g:session_persist_globals, 'g:magiLayoutMode')

"| 3. Keybinds
    " Core actions
        " Del and Bsp
            " Make bsp work in Windows
            set backspace=eol,start,indent
            nnoremap <bs> "_X
            nnoremap <del> "_x

            "Only windows
            inoremap <c-BS> <c-w>
            cnoremap <c-BS> <c-w>

            "Only mac (linux?)
            inoremap <m-BS> <c-w>
            cnoremap <m-BS> <c-w>

        " Undo
            noremap U <c-r>
            "noremap <silent> u :<c-u>call WrapperForKeyU()<cr>
            "fun! WrapperForKeyU()
            "    if v:count >= 1
            "        call RemoveBuffer(v:count)
            "    else
            "        normal! u
            "    endif
            "endfun

        " Insert and paste
            let g:Insertatron_easykeymaps = 1
            noremap v r

        " For autocomplete
            fun! TabToAutocomplete(direction)
                return IsBlank('.') || IsWhitespace('.') ?
                    \ (a:direction == 'forward' ? "\<tab>" : "\<bs>") :
                    \ (a:direction == 'forward' ? "\<c-n>" : "\<c-p>")
            endfun
            inoremap <tab> <c-r>=TabToAutocomplete('forward')<CR>
            inoremap <s-tab> <c-r>=TabToAutocomplete('backward')<CR>
            set completeopt +=longest
            set complete =.,w

        " Action by inaction
            " ie. train self not to use these keys
            noremap I <nop>
            noremap A <nop>
            noremap O <nop>
            noremap P <nop>
            nnoremap $ <nop>
            "noremap p <nop>
            "noremap b <nop>
            "noremap m <nop>
            "noremap / <nop>
            "noremap gg <nop>
            map gg g
            noremap gf <nop>
            "noremap G <nop>
            nnoremap ) <nop>
            nnoremap ( <nop>

            imap <c-a> <nop>
            imap <c-t> <nop>

            imap <d-w> <nop>
            imap <d-r> <nop>
            imap <d-t> <nop>

            imap <d-a> <nop>
            imap <d-s> <nop>
            imap <d-f> <nop>

            imap <d-z> <nop>
            imap <d-x> <nop>
            imap <d-c> <nop>
            imap <d-v> <nop>

            vmap qo <nop>

    " Getting around
        " Reassign hjkl
            noremap j h
            noremap ; l

            " PURPOSE - set jump history for multi-line moves (look at m`)
            noremap k k
            nnoremap <silent> k :<c-u>call WrapperForKey_k()<cr>
            fun! WrapperForKey_k()
                if v:count >= 1
                    exe "normal! " . v:count. "km`\<c-o>"
                else
                    normal! k
                endif
            endfun

            noremap l j
            nnoremap <silent> l :<c-u>call WrapperForKey_l()<cr>
            fun! WrapperForKey_l()
                if v:count >= 1
                    exe "normal! " . v:count. "jm`\<c-o>"
                else
                    normal! j
                endif
            endfun

        " Simple navigation
            noremap <space> zz
            noremap <return> zt
            "noremap <enter> zt
            noremap W zb
            noremap E zt

            " PURPOSE - H/L are strangely slow on folds
            nnoremap <silent> w :call cursor(line('w0'), 0)<cr>
            nnoremap <silent> e :call cursor(line('w$'), 0)<cr>
            vnoremap w H
            vnoremap e L
            "vnoremap <silent> w :<c-u>call MoveCursor_toWindowTop('v')<cr>
            "vnoremap <silent> e :<c-u>call MoveCursor_toWindowBottom('v')<cr>

        " Misc nav remaps
            "noremap gf G
            noremap # $
            noremap gb b
            noremap ge e
            noremap gw w

        " Key mappings for search
            let g:indexed_search_mappings = 0
            set shortmess+=s

            noremap<silent> * *:set hlsearch<cr>zv
            noremap<silent> & #:set hlsearch<cr>zv
            noremap<silent> n n:set hlsearch<cr>zv
            noremap<silent> N N:set hlsearch<cr>zv

            "noremap ' :set hlsearch<cr>/
            "noremap ' :set hlsearch<bar>ShowSearchIndex<cr>/
            "noremap ' :set hlsearch<bar>call Refresher()<bar>ShowSearchIndex<cr>/
            noremap ' :call WrapperForSearch()<cr>/
            noremap <silent> / :call Scroller_refreshSearchResults()<cr>
            fun! WrapperForSearch()
                set hlsearch
                if exists("b:Scroller_searchPlacement")
                    unlet b:Scroller_searchPlacement
                endif
                "call Scroller_triggerRefresh()
                "normal! /
            endfun

    " All operators
        " Operator by itself
            noremap x <
            noremap c >

            noremap t "+y
            noremap d "+d
            nnoremap da "_d
            vnoremap a "_d
            noremap z "_c

            noremap y .

        " Operator with motion
            nnoremap xx <<
            nnoremap cc >>

            nnoremap tt "+yy
            nnoremap te "+ye
            nnoremap tw "+yw
            nnoremap to "+yi
            nnoremap ti "+yiw
            nnoremap tsf; "+y$
            nnoremap tsfj "+y^
            nnoremap tsfk "+ygg
            nnoremap tsfl "+yG

            nnoremap dd "+dd
            nnoremap de "+de
            nnoremap dw "+dw
            nnoremap do "+di
            nnoremap di "+diw
            nnoremap dsf; "+d$
            nnoremap dsfj "+d^
            nnoremap dsfk "+dgg
            nnoremap dsfl "+dG

            nnoremap daa "_dd
            nnoremap dae "_de
            nnoremap daw "_dw
            nnoremap dao "_di
            nnoremap dai "_diw
            nnoremap dasf; "_d$
            nnoremap dasfj "_d^
            nnoremap dasfk "_dgg
            nnoremap dasfl "_dG

            nnoremap zz "_cc
            nnoremap ze "_ce
            nnoremap zw "_cw
            nnoremap zo "_ci
            nnoremap zi "_ciw
            "nnoremap z; "_cl
            "nnoremap zj "_ch
            nnoremap zsf; "_c$
            nnoremap zsfj "_c^
            nnoremap zsfk "_cgg
            nnoremap zsfl "_cG

        " Comments
            let commentKey = 'q'
            nmap q <plug>TComment_gc
            nmap qq <Plug>TComment_gcc
            nmap q; <Plug>TComment_Comment
            nmap qj <Plug>TComment_Uncomment

            vmap qq :TComment<cr>
            vmap q; <Plug>TComment_Comment
            vmap qj <Plug>TComment_Uncomment

        " For vim-surround
            let g:surround_no_mappings = 1
            nmap ds <Plug>Dsurround
            nmap cs <Plug>Csurround
            nmap ts <Plug>Ysurround
            nmap tsi <Plug>Ysurroundiw

            "Rarely useful, maybe to add more delims
            "nmap tso <Plug>Ysurroundi
            "nmap tss <Plug>Yssurround
            "xmap S <Plug>VSurround
            "nmap cS  <Plug>CSurround
            "nmap ys  <Plug>Ysurround
            "nmap yS  <Plug>YSurround
            "nmap yss <Plug>Yssurround
            "nmap ySs <Plug>YSsurround
            "nmap ySS <Plug>YSsurround
            "xmap S   <Plug>VSurround
            "xmap gS  <Plug>VgSurround

    " Other
        " Managing files and views
            nnoremap qw :xa<cr>
            nnoremap qu :call UnloadCurrentBuffer()<cr>
            nnoremap qy :MBEbd! <cr>
            nnoremap <silent> qi :q<cr>

            fun! UnloadCurrentBuffer()
                update
                MBEbd
            endfun

            " NOTE: For below, didn't add <cr> on purpose, as a check to make sure
            nnoremap qh :call DeleteSession()
            nnoremap qn :call delete(expand('%'))

        " Pull up recent commands + searches
            " Most recent cmd
            nnoremap qo :<c-p>

            " All cmds (in a sep win)
            nnoremap qp q:

            " Searches (in a sep win)
            noremap q[ q/

        " Follow links in help
            nnoremap q' <c-]>
        " For scoutkey
            nnoremap <silent> s :<c-u>call ScoutKey()<cr>

            " External code can't do these moves bc of core vim limitation, so put here
            vnoremap sfl G
            vnoremap sfk gg
            vnoremap sf; $
            vnoremap sfj ^

"| 4. Setup auto-commands
    if !exists("g:loadOnce_onFirstSource")
        let g:loadOnce_onFirstSource = 1

        " Appearance and formatting
            " Syntax highlighting per language
                au FileType python call PythonSyntaxHl()
                au FileType html call HtmlSyntaxHl()
                au FileType javascript call JsSyntaxHl()
                au BufRead,BufNewFile *.to call TodoSyntaxHL()

            " Highlight orphaned whitespace
                "au BufRead * call HL_OrphanedWhitespace()

                highlight OrphanedWhitespace guibg=grey30 ctermbg=grey
                fun! HL_OrphanedWhitespace()
                    match OrphanedWhitespace /\s\+\%#\@<!$/
                    "match OrphanedWhitespace /\s\+$/
                endfun
                fun! OrphanedWhitespace_search()
                    "execute "normal! /^\\s\\+$\<cr>"
                    %s/\s\+$//c

                    "call HL_OrphanedWhitespace()
                    " Todo - could make this much more sophisticated
                    " 1. tells you how many orphaned blocks are left below
                    " 2. simply clears ALL orphaned
                endfun

                " Turn it off if distracting
                "fun! HighlightWhitespace_clear()
                "    highlight ExtraSpace guibg=NONE ctermbg=NONE
                "endfun

            " Maximize window
                if has('win32')
                    "set lines=999 columns=999
                    au GUIEnter * simalt ~x
                else
                    au GUIEnter * call system('wmctrl -i -b add,maximized_vert,maximized_horz -r '.v:windowid)
                    "set lines=999 columns=999
                endif

            " Turns off bells fo REAL
                au GUIEnter * set vb t_vb=

            " Makes help appear as vertical split (instead of horiz)
                "au FileType help call WhenHelp()
                "fun! WhenHelp()
                "    wincmd L
                "endfun

            " Refresh when switching back to vim
                autocmd FocusGained * redraw!

            " Disable autocomments
                au FileType * setlocal formatoptions-=c formatoptions-=r formatoptions-=o

            " Stop folding for help/mbe/noname
                "au FileType * call StartFolding()
                au FileType * call PreventFolding()
                fun! PreventFolding()
                    if &buftype == 'help' || &buftype == 'nofile'
                        setlocal foldmethod=manual
                        "setlocal foldexpr =0
                        "setlocal nofoldenable
                    endif
                endfun

            " Stop folding for large files (1mb or bigger)
                let g:FileSizeMax = 1024 * 1000 "1mb
                autocmd BufReadPre * call HandleLargeFile('pre')
                autocmd BufReadPost * call HandleLargeFile('post')
                "autocmd FileType javascript call LargeFile('filetype')

        " Save session, load session
            " Order
            "   open vim > noname > session load > open mbe
            "   start close > close mbe > session save > exit

            set sessionoptions=blank,buffers,curdir,tabpages,winpos
            "set sessionoptions=blank,buffers,curdir,folds,tabpages,winpos
            "set sessionoptions=blank,buffers,curdir,folds,help,tabpages,winpos
            if has("gui_running")
                let g:session_autosave = 'yes'
                let g:session_autoload = 'yes'
            else
                let g:session_autosave = 'no'
                let g:session_autoload = 'no'
            endif
            let g:session_directory = g:dir_vim . 'session'

            "au VimLeavePre * MBEClose "redundant with tempBuffers
            au VimLeavePre * call setqflist([]) "So session.vim doesn't save quickfix list
            au VimLeavePre * silent! argdel * "So session.vim doesn't save args
            au VimLeavePre * call CloseTempBuffers()
            au SessionLoadPost * call WhenSessionLoad()

            "execute 'nnoremap xu :mksession! ~/.vim/session/base.vim<cr>'
            "execute 'nnoremap xi :source ~/.vim/session/base.vim<cr>'

        " Other
            " not autocmd, but want default on (but can be toggled off later)
                set nowrap
                set hlsearch
                set incsearch
                "set lines=40 columns=150

                " Set cwd to home
                exe "cd ~"
            " For debugging autocmds
                "set verbose=9
                "au

    endif


""" Trying this stuff out
    " Keys for navigating jumps (setting marks, walking thru jump history)
        "noremap hs mH
        "noremap hd `H
        noremap hs :call SetMark()<cr>
        noremap hd :call JumpToMark()<cr>
        noremap ha <c-o>
        noremap hf <c-i>
        "noremap hg :call JumpReset()<cr>
        "fun! JumpReset()
        "    normal! <C-I>
        "endfun
        "TODO - simply press <c-i> 10 times (hackish = close enough)
        fun! SetMark()
            normal! mH
            echom "Custom mark was set"
        endfun
        fun! JumpToMark()
            normal! `H
            echom "Jumped to mark"
        endfun


    noremap <tab> v
    map p :call JumpToFold(1)<cr>
    map P :call JumpToFold(-1)<cr>
    "noremap / <nop>
    "nnoremap qm :cd %:p:h <cr>
    noremap hh :update <bar> MbeRefresh<cr>

    fun! JumpToFold(direction)
        let nCurr = GetFoldBounds('.', a:direction)
        let nBound = (a:direction == 1 ? line('$') : 1)
        if nCurr == nBound
            return
        endif

        let i = nCurr + a:direction
        while !IsFolded(i) && i != nBound
            let i += a:direction
        endwhile
        call cursor(i, 0)
    endfun


    if !exists("g:loadOnce_test")
        let g:loadOnce_temp = 1

        " Hack to turn off indentexpr (for python)
        autocmd BufRead,BufNewFile * set indentexpr=
        autocmd BufRead,BufNewFile * set autoindent
        " TODO: prevent run of indent/<lang>.vim
        "autocmd Filetype * let b:did_indent = 1
    endif


    "!open -a Terminal.app .
    "NOTE - Don't need to open terminal bc can do all bash in vim!

    fun! FindNextIndentError()
        " Todo - Doesn't handle folding. Not worth it

        let nStart = line('.')
        let EOF = line('$')
        let firstFound = 0
        let numFound = 0

        if nStart == EOF
            return
        endif

        for i in range(nStart+1, EOF-1)
            if IsBlank(i)
                continue
            endif

            " Grab data on this line
            let nCurr = i
            let nNext = nextnonblank(i+1)
            if nNext == 0
                break
            endif
            let indCurr = indent(i)
            let indNext = indent(nNext)
            let indDiff = indNext - indCurr

            if (indCurr % &shiftwidth != 0)
                let firstFound = (!firstFound ? nCurr : firstFound)
                let numFound += 1

            elseif indDiff > &shiftwidth
                let firstFound = (!firstFound ? nNext : firstFound)
                let numFound += 1

            elseif indDiff < -&shiftwidth
                let nPrev = prevnonblank(i-1)
                let textPrev = getline(nPrev)
                if match(textPrev, '^\s\+\(if\|else\|for\|} else\)') == -1 || textPrev[-1:] == '{'
                    if textPrev[-1:] != ':'
                        let firstFound = (!firstFound ? nNext : firstFound)
                        let numFound += 1
                    endif
                endif
            endif
        endfor

        call cursor(firstFound, 0)
        echom "Ind errors remaining: " . numFound
    endfun


    let g:netrw_banner = 0
    let g:netrw_keepdir = 0

    fun! ClearAllUndoHistory()
        let old_undolevels = &undolevels
        let old_modified = &modified

        set undolevels=-1
        call setline(line('.'), getline('.'))

        let &undolevels = old_undolevels
        let &modified = old_modified
        unlet old_undolevels
        unlet old_modified
    endfun


    " Grep and search
        command! -nargs=? Indexer call GrepMe(<f-args>)

        fun! GrepMe(...)
            " Format query
            " TODO: grep is fine with single quotes ('), but doesn't acknowledge double quotes (")
            if a:0 == 0 "if no args
                let searchQuery = getreg('/')
                let searchQuery = (searchQuery[0:1] == '\<' && searchQuery[-2:-1] == '\>' ? searchQuery[2:-3] : searchQuery)
            else
                let searchQuery = a:1
                let @/ = a:1
            endif

            " Execute grep
            try
                exe 'silent grep' '"'.searchQuery.'" *'
            catch
                echom "invalid input"
                return
            endtry

            " Format result
            set hlsearch
            set foldlevel=99
            redraw!

            " Prep quickfix window
            copen
            if &filetype == "qf"
                call setwinvar(0, "&statusline", '  Found '.len(getqflist())." for [".searchQuery."]")
                "set ffs=dos
                "silent g/\\\$/s///
                redraw!
            endif
        endfun

        " Testing why "set hlsearch" does not work on initial run *within function body*
            "fun! Tester()
            "    "nohlsearch
            "    let @/='string'
            "    setglobal hls
            "    ":nnoremap <F8> :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>
            "endfun
            "nnoremap <F8> :set hls<CR>
            "nnoremap <F8> :call Tester()<CR>

        let g:ag_apply_qmappings = 0


    " Manage dups for MBE fname tails
        "GIVEN
        let bufs = [1,7,3,9,10,2, 4]
        let g:correspondence = {
            \'1':  'C:\f2',
            \'7':  'C:\g\a\f',
            \'3':  'C:\h\b\f',
            \'9':  'C:\i\c\b\f',
            \'10': 'C:\f3',
            \'2':  'C:\j\d\b\f',
            \'4':  'C:\k\e\d\b\f',
        \}
        "WANT
        let want = [ [1,""], [7,"a"], [3, "h" ], [9, "c"], [10, ""], [2, "j"], [4,"e"]]

        "let bufs = [7,3]
        "let g:correspondence = {
        "    \'7':  'C:\a\f',
        "    \'3':  'C:\b\f',
        "\}
        "let want = [ [7,"a"], [3, "b" ]]


        fun! Manage(bufNums)
            " Assume fnameArr has *full path* (not tail or shortened path)
            let dct = {}
            for bufNum in a:bufNums
                let fullPath = g:correspondence[bufNum]

                let tail = fnamemodify(fullPath, ':t')
                if has_key(dct, tail)
                    call add(dct[tail], bufNum)
                else
                    let dct[tail] = [bufNum]
                endif
            endfor
            echo dct

            for tail in keys(dct)
                let bufNums = dct[tail]
                if len(bufNums) > 1
                    call s:manage(bufNums)
                endif
            endfor
        endfun

        " NOTE: only use bufNums and finished
        fun! s:manage(bufNums)
            echo 'yes' a:bufNums

            " Race!
            let finished = []
            let level = -1
            "while len(a:bufNums) > 0
            "while level > -5
            while len(a:bufNums) > 0
                let level -= 1
                call s:manage2(a:bufNums, level, finished)
            endwhile

            echo finished
            "return finished
        endfun

        fun! s:manage2(bufNums, level, finished)
            " Are there any diff parents in this level?
            let parents = {}
            for bufNum in a:bufNums
                let splitPath = split(g:correspondence[bufNum], '\')
                "echo 'splitPath:' splitPath
                let parent = splitPath[a:level]
                "echo 'parent:' parent

                if has_key(parents, parent)
                    call add(parents[parent], bufNum)
                else
                    let parents[parent] = [bufNum]
                endif
            endfor
            "echo 'parents' parents

            " TODO: any are not dups?
            for parentName in keys(parents)
                let bufNums = parents[parentName]
                if(len(bufNums) == 1)
                    let bufNum = bufNums[0]
                    echo 'bufNum' bufNum
                    call add(a:finished, [bufNum, parentName])
                    call remove(a:bufNums, index(bufNums, bufNum))
                endif
            endfor
        endfun



    " Trying to use ag
        if executable('ag')
            " Use Ag over Grep
            let ignore_dirs = ['CVS', 'node_modules', '.venv']

            let &grepprg = 'ag -s --nogroup --nocolor'
            for ignore_dir in ignore_dirs
                let &grepprg .= ' --ignore-dir ' . ignore_dir
            endfor

            " Use ag in CtrlP for listing files. Lightning fast and respects .gitignore
            "let g:ctrlp_user_command = 'ag -l --nocolor -g "" %s'

            " ag is fast enough that CtrlP doesn't need to cache
        elseif has('win32')
            set grepprg=findstr\ /n\ /s
        "elseif has('unix')
        "   e
        endif


    command! FileExplorer call OpenExplorer()

    " TODO: figure out why I had this
    "set viewoptions =folds

    " Refresh results for Scroller()
        " NOTE - currently using '/' instead of refresh
        "let &ut = 300
        "autocmd CursorHold * if line('$')<3000 | call Scroller_refreshSearchResults() | endif
